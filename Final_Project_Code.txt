
;Project Title: DISCREAT CALCULATOR
;Group Members: M.Owais Mushtaq (18k-1177), Haris Ahmed (18k-1162), Usman Umer (18k-1069)
;Section: G

INCLUDE Irvine32.inc

.data

T1 BYTE"========================================================================================================================",0
T2 BYTE"                                             DISCREATE CALCULATOR                                                       ",0
MSG1 BYTE"			1. CONVERTING SENTENCE INTO LOGIC EXPRESSION  ",0
MSG2 BYTE"			2. CONVERTING LOGICAL EXPRESSION INTO SENTENCE ",0
MSG3 BYTE "			3. GENERATING TRUTH TABLE",0
MSG4 BYTE "			4. Caesar Encryption and Decryption",0 

QUIT BYTE "			0. QUIT",0
CHOICE BYTE"			Please Enter the Suitable Option From the Above:  ",0
AND_OPERATOR BYTE "and",0
OR_OPERATOR BYTE "or",0
BICONDITION_OPERATOR BYTE " if and only if",0
IMPLIES_OPERATOR1 BYTE " If",0
IMPLIES_OPERATOR2 BYTE " then",0

OPERATION BYTE "	After Performing Selected Operation: ",0
WRONG BYTE"			WRONG INPUT!",0
SEN BYTE"		Sentence No.",0
NOTE BYTE"	To Avoid Sentence Format Error, System has defined following Sentences for you ",0
lINE BYTE"________________________________________________________________________________________________________________________",0
SENTENCE BYTE" I will use all my savings to travel to Europe ",0	
SENTENCE1 BYTE " I'll buy an Electric Car",0
SENTENCE2 BYTE" you'll get 100% marks in the final",0 
SENTENCE3 BYTE" you will get an A+",0 
SENTENCE4 BYTE" You can take the flight",0
SENTENCE5 BYTE" you buy a ticket",0



L_SEN1 BYTE "			1. PERFORM AND OPERATION",0
L_SEN2 BYTE "			2. PERFORM OR OPERATION",0
L_SEN3 BYTE "			3. PERFORM IMPLIES OPERATION",0
L_SEN4 BYTE "			4. PERFORM BI-CONDITIONAL OPERATION",0
PREV BYTE"			11. BACK ",0
 
ENCRYPT BYTE"			1. PERFORM ENCRYPTION ON SENTENCE",0
DECRYPT BYTE"			2. PERFORM DECRYPTION ON SENTENCE",0
CRYPTOSEN BYTE 30 DUP(?)
SAVE BYTE 30 DUP(?)
DISPLAY BYTE "ENTER SENTENCE ",0
DISPLAY1 BYTE "ENTER THE VALUE OF K",0
K BYTE ?

P BYTE "F",0
Q BYTE "T",0
R BYTE "F",0
TEMP1 BYTE 6 DUP(?)
TEMP BYTE 6 DUP(?)
TABLE BYTE "=========================================================================",0
TABLE1 BYTE " | ",0 
TABLE_MSG BYTE "ENTER THE EXPRESSION FOR TRUTH TABLE:",0
TABLE_MSG2 BYTE "NOTE:use <-> for BICONDITIONALS statement, -> for IMPLICATION operation, + for OR operation , . for AND operation AND don't use a variable more than once",0
TABLE_MSG3 BYTE "NOTE:It can only generate truth table of atmost three variables and atleast two variables",0
EXPRESSION BYTE 20 DUP(?)
VARIABLE_COUNT DWORD 0

FINDLOG BYTE"		Enter Sentance to Convert into Logical Expression: ",0
STATEMENT BYTE 60 DUP(?)            ;STATEMNT TO LET USER KN
STATEMENT1 BYTE 60 DUP(?)
STRING2 BYTE 100 DUP(?)                  ;STRING FROM WHERE STRING NEED TO BE SEARCHED
STR1 BYTE "AND",0
STR2 BYTE "OR",0
STR3 BYTE "IF AND ONLY IF",0	;STRING THAT NEED TO BE SEARCHED
L DWORD ?
P_EQU BYTE "LET	P = ",0
Q_EQU BYTE "	Q = ",0
PQ_AND BYTE "LOGICAL EXPRESSION:	P & Q",0
PQ_OR BYTE "LOGICAL EXPRESSION:		P V Q",0
PQ_BI BYTE "LOGICAL EXPRESSION:		P <-> Q",0
TEMP3 DWORD ?
TEMP4 DWORD ?
TEMP5 DWORD ?

.code
	
main proc 
																											; Main Frame
MENU:
	CALL CLRSCR
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET T2 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET MSG1	 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET MSG2
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET MSG3 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET MSG4 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	CALL CRLF

	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP AX,1
	JE C1 
	CMP AX,2
	JE C2
	CMP AX,3
	JE C3
	CMP AX,4
	JE C4
	CMP AX,0
	JE BYE

	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	JMP MENU

	C1:
	CALL Sentence_To_Logic
	JMP MENU
	C2:
	CALL Logic_To_Sentence
	JMP MENU
	C3:
	CALL Generating_Turth_Table
	JMP MENU
	C4:
	CALL Shift_Cipher
	JMP MENU 

	BYE:
		EXIT
exit
main ENDP

Sentence_To_Logic PROC																				; Fuction 1. CONVERTING SENTENCE INTO LOGIC EXPRESSION 
LOCAL VAR1:BYTE

	mov eax,0
	CALL CLRSCR
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET MSG1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF


	MOV EDX,OFFSET FINDLOG
	CALL WRITESTRING
	CALL CRLF

	CLD ; CLEAR DIRECTION FLAG
	MOV EAX,0
	MOV ESI,0
	MOV EDX,0
	MOV EDX,OFFSET STRING2
	MOV ECX,LENGTHOF STRING2

	CALL READSTRING
	INVOKE STR_UCASE, ADDR STRING2   
	CALL CRLF   
	MOV VAR1,AL
	cmp al,0
	je l101
	MAINLY:
	MOV EDX,0
	MOV EDI,OFFSET STRING2
	CMP AH,0
	JE  SET
	CMP AH,1
	JE SET1
	CMP AH,2
	JE SET2
	l101:
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	EXIT
	
	L2:
	MOVZX ECX,VAR1
	MOV L,ECX
	L1:

	MOV AL,[ESI]
	CMP EDX,TEMP3
	JE START
	SCASB
	JZ WR
	JNZ ELS

	WR:
	INC TEMP4
	INC EDX      ;WHENEVER CHARATER EXIST EDX GET AND NOW THE OTHER CHARACTER WILL BE SEARCHED
	INC ESI
	JMP ENDING

	ELS:
	INC TEMP4
	MOV ESI,TEMP5
	MOV EDX,0
	ENDING:
	LOOP L1

	START:
	CLD	
	MOV EBX,TEMP3
	CMP EDX,EBX           ;;IN THE END THE END IF STRING EXIST STRING THAT NEED TO BE SEARCHED AND EDX WILL HAVE SAME LENGTH
	;CALL DUMPREGS
	JE EQUAL
	INC AH			;IF STRING NOT FIND
	JMP MAINLY
	MOV EDX,OFFSET STATEMENT1
	CALL WRITESTRING
	EXIT
	
	EQUAL:
	MOV BL,[EDI]
	CMP BL,40H
	JA ELS
	MOV EBX,TEMP4
	SUB EBX,TEMP3
	MOV ECX,EBX
	CLD
	MOV ESI,OFFSET STRING2	
	MOV EDI,OFFSET STATEMENT
	REP MOVSB
	MOV EDX,OFFSET P_EQU
	CALL WRITESTRING
	MOV EDX,OFFSET STATEMENT
	CALL WRITESTRING
	CALL CRLF

	CLD
	ADD EBX,TEMP4
	MOV ECX,EBX
	MOV ESI,OFFSET STRING2
	MOV EDI,OFFSET STATEMENT1
	ADD ESI,TEMP4
	REP MOVSB
	MOV EDX,OFFSET Q_EQU
	CALL WRITESTRING
	MOV EDX,OFFSET STATEMENT1
	CALL WRITESTRING
	CALL CRLF
	CMP AH,0
	JE JM_P
	CMP AH,1
	JE P1
	CMP AH,2
	JE P2
	JM_P:
	CALL CRLF
	MOV EDX,OFFSET PQ_BI
	CALL WRITESTRING
	CALL CRLF
	JMP FSQUIT
	
	P1:
	CALL CRLF
	MOV EDX,OFFSET PQ_OR
	CALL CRLF
	CALL WRITESTRING
	JMP FSQUIT
	
	P2:
	CALL CRLF
	MOV EDX,OFFSET PQ_AND
	CALL WRITESTRING
	CALL CRLF
	JMP FSQUIT

	SET:
	MOV TEMP4,0
	MOV ESI ,OFFSET STR3
	MOV TEMP3,LENGTHOF STR3-1
	MOV TEMP5,OFFSET STR3
	JMP L2
	
	SET1:
	MOV TEMP4,0
	MOV ESI,OFFSET STR2
	MOV TEMP3,LENGTHOF STR2-1
	MOV TEMP5,OFFSET STR2
	JMP L2
	
	SET2:
	MOV TEMP4,0
	MOV ESI,OFFSET STR1
	MOV TEMP3,LENGTHOF STR1-1
	MOV TEMP5,OFFSET STR1
	JMP L2






FSQUIT:

	CALL CRLF
	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE S5
	CMP	AX,0 
	JE S6
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	CALL Sentence_To_Logic
	ret

	S5:
	RET
	EXIT

	S6:
	EXIT




	Exit
	Sentence_To_Logic ENDP















Logic_To_Sentence PROC																					; Fuuntion 2. CONVERTING LOGICAL EXPRESSION INTO SENTENCE

	mov eax,0
	CALL CLRSCR
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET MSG2 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET L_SEN1
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET L_SEN2
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET L_SEN3
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET L_SEN4
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	

	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP AX,1
	JE S1
	CMP AX,2
	JE S2
	CMP AX,3
	JE S3
	CMP	AX,4 
	JE S4 
	CMP	AX,11 
	JE S5
	CMP	AX,0 
	JE S6
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	CALL Logic_To_Sentence
	ret

	S1:																											;AND OPERATOP
	
	CALL CLRSCR
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET NOTE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,01
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,02
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE1
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET OPERATION
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET SENTENCE
	CALL WRITESTRING
	MOV EDX,OFFSET AND_OPERATOR
	CALL WRITESTRING
	MOV EDX,OFFSET SENTENCE1
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF


	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE SL1
	CMP	AX,0 
	JE SL2
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	JMP S1
	RET

	SL1:
	CALL Logic_To_Sentence
	RET
	EXIT

	SL2:
	EXIT
	CALL Logic_To_Sentence
	ret

	S2:																												; OR OPREATION 
	
	CALL CLRSCR
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET NOTE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,01
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,02
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE1
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET OPERATION
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF

	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET SENTENCE
	CALL WRITESTRING
	MOV EDX,OFFSET OR_OPERATOR
	CALL WRITESTRING
	MOV EDX,OFFSET SENTENCE1
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF


	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE SL3
	CMP	AX,0 
	JE SL4
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	JMP S2
	RET

	SL3:
	CALL Logic_To_Sentence
	RET
	EXIT

	SL4:
	EXIT
	CALL Logic_To_Sentence
	ret

	S3:																										;IMPLIES OPERATION

	CALL CLRSCR
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET NOTE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,01
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE2
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,02
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE3
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET OPERATION
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF

	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET IMPLIES_OPERATOR1
	CALL WRITESTRING
	MOV EDX,OFFSET SENTENCE2
	CALL WRITESTRING
	MOV EDX,OFFSET IMPLIES_OPERATOR2
	CALL WRITESTRING
	MOV EDX,OFFSET SENTENCE3
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF


	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE SL5
	CMP	AX,0 
	JE SL6
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	JMP S3
	RET

	SL5:
	CALL Logic_To_Sentence
	RET
	EXIT

	SL6:
	EXIT


	CALL Logic_To_Sentence
	ret

	S4:																								;BICONDIONDAL OPERATION
	CALL CLRSCR
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET NOTE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,01
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE4
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET SEN
	CALL WRITESTRING
	MOV AL,02
	CALL WRITEDEC
	MOV EDX,OFFSET SENTENCE5
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET OPERATION
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET SENTENCE4
	CALL WRITESTRING
	MOV EDX,OFFSET BICONDITION_OPERATOR
	CALL WRITESTRING
	MOV EDX,OFFSET SENTENCE5
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET LINE
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF


	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE SL7
	CMP	AX,0 
	JE SL8
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	JMP S4
	RET

	SL7:
	CALL Logic_To_Sentence
	RET
	EXIT

	SL8:
	EXIT
	
	
	CALL Logic_To_Sentence
	ret
	
	S5:
	RET
	EXIT

	S6:
	EXIT

																						
																						
																				
Logic_To_Sentence ENDP


not_operation PROC,op:PTR BYTE
	MOV ESI,op
	MOV AL,[ESI]
	CMP AL,'F'
	JE convert_to_true
	MOV AL,'F'
	MOV [ESI],AL
	JMP not_jmp

	convert_to_true:
		MOV AL,'T'
		MOV [ESI],AL

	not_jmp:
		RET

not_operation ENDP

and_operation PROC,first:BYTE,second:BYTE
	CMP first,'T'
	JE and_tes
	and_false:
		MOV AL,'F'
		RET

	and_tes:
		CMP second,'T'
		JNE and_false
		MOV AL,'T'
		RET

and_operation ENDP

or_operation PROC,first:BYTE,second:BYTE
	CMP first,'F'
	JE or_tes
	or_true:
		MOV AL,'T'
		RET

	or_tes:
		CMP second,'F'
		JNE or_true
		MOV AL,'F'
		RET

or_operation ENDP

implies_operation PROC,first:BYTE,second:BYTE
	CMP first,'T'
	JE implies_tes
	implies_true:
		MOV AL,'T'
		RET
		
	implies_tes:
		CMP second,'F'
		JNE implies_true
		MOV AL,'F'
		RET	

implies_operation ENDP

biconditional_operation PROC,first:BYTE,second:BYTE
	MOV AL,first
	CMP AL,second
	JNE biconditional_false
	MOV AL,'T'
	RET

	biconditional_false:
		MOV AL,'F'
		RET
biconditional_operation ENDP

two_variable_sol PROC,two_sol:PTR BYTE,len:DWORD,two_var1:BYTE,two_var2:BYTE
	PUSH ECX
	MOV ESI,two_sol
	MOV ECX,len
	two_so:
		MOV AL,[ESI]
		CMP AL,'+'
		JE two_or
		CMP AL,'.'
		JE two_and
		CMP AL,'<'
		JE two_bi
		CMP AL,'-'
		JE two_imp
		two_sol2:
			INC ESI
			loop two_so
			POP ECX
			RET

		two_or:
			INVOKE or_operation,two_var1,two_var2
			POP ECX
			RET

		two_and:
			INVOKE and_operation,two_var1,two_var2
			POP ECX
			RET

		two_bi:
			INVOKE biconditional_operation,two_var1,two_var2
			POP ECX
			RET

		two_imp:
			INVOKE implies_operation,two_var1,two_var2
			POP ECX
			RET

two_variable_sol ENDP

three_variable_sol PROC,exp:PTR BYTE,len:DWORD,three_var1:BYTE,three_var2:BYTE,three_var3:BYTE
						LOCAL result:BYTE
	push ECX
	MOV ESI,exp
	MOV ECX,len
	MOV EDI,OFFSET temp1
	three_sol:
		MOV AL,[ESI]
		CMP AL,'('
		JE three_two

		MOVSB

		three_jmp:
			LOOP three_sol

		


		three_two:
			PUSH EDI
			MOV EDI,OFFSET temp
			INC ESI
			PUSH ECX
			MOV ECX,3
			REP MOVSB
			POP ECX
			CMP ECX,len
			JE three_sol1
			INVOKE two_variable_sol,ADDR temp,3,three_var2,three_var3
			SUB ECX,5
			MOV result,AL
			POP EDI
			MOV AL,'Q'
			MOV [EDI],AL
			INC EDI
			INVOKE two_variable_sol,ADDR temp1,3,three_var1,result
			POP ECX
			RET

			three_sol1:
				INVOKE two_variable_sol,ADDR temp,3,three_var1,three_var2
				MOV result,AL
				SUB ECX,5
				POP EDI
				MOV AL,'P'
				MOV [EDI],AL
				INC EDI
				MOV ECX,3
				MOV ESI,exp
				ADD ESI,5
				REP MOVSB
				INVOKE two_variable_sol,ADDR temp1,3,result,three_var3
				POP ECX
				RET



three_variable_sol ENDP


;FUNCTION TO COUNT THE NUMBER OF VARIABLES IN THE EXPRESSION
count_variable PROC,exp:PTR BYTE,no:DWORD
	MOV ESI,EDX
	MOV ECX,no
	MOV EDI,0
	L1:
		MOV BL,'A' 
		MOV AL,[ESI]
		CMP AL,BL
		JAE tes
		JMP L2
		
	tes:
		MOV BL,'Z'
		MOV AL,[ESI]
		CMP AL,BL
		JBE count
		JMP L2

	count:
		INC EDI
		JMP	L2

		L2:
			INC ESI
	LOOP L1
	RET

count_variable ENDP

Generating_Turth_Table PROC																			;FUNCTION 3. GENERATING TRUTH TABLE
	
	mov eax,0
	CALL CLRSCR
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET MSG3 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	mov eax,0

	MOV EDX,OFFSET table_msg3
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF

	MOV EDX,OFFSET table_msg2
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF

	MOV EDX,OFFSET table_msg
	CALL WRITESTRING
	CALL CRLF

	MOV EDX,OFFSET expression
	MOV ECX,19
	CALL READSTRING
	INVOKE STR_UCASE,ADDR expression

	CALL STRLENGTH

	INVOKE count_variable,ADDR expression,EAX
	CMP EDI,2
	JE two_variable
	CMP EDI,3
	JE three_variable

	two_variable:
		MOV EAX,'P'
		CALL WRITECHAR
						
		MOV EDX,OFFSET table1
		CALL WRITESTRING

		MOV EAX,'Q'
		CALL WRITECHAR

		MOV EDX,OFFSET table1
		CALL WRITESTRING

		MOV EDX,OFFSET expression
		CALL WRITESTRING
		CALL CRLF

		MOV EDX,OFFSET table
		CALL WRITESTRING
		CALL CRLF

		MOV ECX,2
			two_outer:
				push ECX
				MOV ECX,2

					two_inner:
						MOV AL,P
						CALL WRITECHAR

						MOV EDX,OFFSET table1
						CALL WRITESTRING

						MOV AL,Q
						CALL WRITECHAR

						MOV EDX,OFFSET table1
						CALL WRITESTRING

						;CALCULATE
						MOV EDX,OFFSET expression
						CALL STRLENGTH
						MOV EBX,EAX
						INVOKE two_variable_sol,ADDR expression,EBX,P,Q
						CALL WRITECHAR
						CALL CRLF

						INVOKE not_operation,ADDR Q
					LOOP two_inner

					POP ECX
					INVOKE not_operation,ADDR P
					DEC ECX
					CMP ECX,0
					JNE two_outer
					MOV EAX,900
	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE S5
	CMP	AX,0 
	JE S6
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	CALL Generating_Turth_Table
	ret

	S5:
	RET
	EXIT

	S6:
	EXIT
				RET
							 
	three_variable:
		MOV EAX,'P'
		CALL WRITECHAR
						
		MOV EDX,OFFSET table1
		CALL WRITESTRING

		MOV EAX,'Q'
		CALL WRITECHAR

		MOV EDX,OFFSET table1
		CALL WRITESTRING

		MOV EAX,'R'
		CALL WRITECHAR

		MOV EDX,OFFSET table1
		CALL WRITESTRING

		MOV EDX,OFFSET expression
		CALL WRITESTRING
		CALL CRLF

		MOV EDX,OFFSET table
		CALL WRITESTRING
		CALL CRLF

		MOV ECX,2
			three_outer:
				PUSH ECX
				MOV ECX,2
				three_inner1:
					push ECX
					MOV ECX,2

						three_inner:
							MOV AL,P
							CALL WRITECHAR

							MOV EDX,OFFSET table1
							CALL WRITESTRING

							MOV AL,Q
							CALL WRITECHAR

							MOV EDX,OFFSET table1
							call WRITESTRING

							MOV AL,R
							CALL WRITECHAR

							MOV EDX,OFFSET table1
							CALL WRITESTRING

							MOV EDX,OFFSET expression
							CALL STRLENGTH

							MOV EBX,EAX

							INVOKE three_variable_sol,ADDR expression,EBX,P,Q,R
							CALL WRITECHAR
						
							CALL CRLF

							INVOKE not_operation,ADDR R
						LOOP three_inner

						POP ECX
						INVOKE not_operation,ADDR Q
					DEC ECX
					CMP ECX,0
					JNE three_inner1

					POP ECX
					INVOKE not_operation,ADDR P
					DEC ECX
					CMP ECX,0
			JNE three_outer

	MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
	CALL READINT
	CMP	AX,11 
	JE TTS5
	CMP	AX,0 
	JE TTS6
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	CALL Generating_Turth_Table
	ret

	TTS5:
	RET
	EXIT

	TTS6:
	EXIT

	RET
Generating_Turth_Table ENDP


	
Shift_Cipher PROC																								;Fuction 4. Caesar’s Encryption and Decryption 
local var:byte

	mov eax,0
	CALL CLRSCR
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	MOV EDX,OFFSET MSG4 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET T1 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET ENCRYPT
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET	DECRYPT
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
		
	call readint
	cmp al,2
	ja CEDquit
	mov var,al
	jmp start
	check:
	add al,k
	jmp l3

	start:

	mov edx,offset display
	call writestring
	call crlf
	mov edx,offset CRYPTOSEN
	mov ecx,lengthof CRYPTOSEN
	call readstring
	invoke str_ucase,addr CRYPTOSEN
	movzx ecx,al
	mov edx,offset display1
	call writestring
	call crlf
	call readint
	mov k,al
	mov esi,offset CRYPTOSEN
	mov edi,0
	mov bl,90

	l1:
	mov al,[esi]
	cmp al,32
	je dep
	cmp var,1
	je check
	cmp var,2
	sub al,k
	l3:
	cmp al,90
	ja l2
	CMP AL,65
	JL E102
	 mov save[edi],aL
	 inc esi
	 inc edi
	 mov ax,0
	loop l1
	JMP FINAL
	dep:
	inc esi
	mov save[edi],al
	inc edi
	loop l1
	jmp final
	 l2:

	 sub aL,26
	 E101:
	 mov save[edi],aL
	 inc edi
	 inc esi
	 mov ax,0	
	 loop l1
	 JMP FINAL
	E102:
	 ADD AL,26
	 JMP E101
	 final:
	mov edx,offset save
	call writestring
	 call crlf
	 CALL  CRLF
	 MOV EDX,OFFSET PREV
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET QUIT 
	CALL WRITESTRING
	CALL CRLF
	CALL CRLF
	MOV EDX,OFFSET CHOICE 
	CALL WRITESTRING
		
	call readint
	CMP AL,11
	JE EDS1
	CMP AL,0
	JE EDS2

	 CEDquit:
	
	MOV EDX,OFFSET WRONG
	CALL WRITESTRING
	MOV EAX,900
	CALL DELAY
	CALL CRLF
	CALL Shift_Cipher
	ret

	EDS1:
	RET
	EXIT

	EDS2:
	EXIT



EXIT
Shift_Cipher ENDP																				



END main